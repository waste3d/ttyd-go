<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Dashboard - Go-ttyd</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #1e1e1e;
            color: #d4d4d4;
            margin: 0;
            padding: 20px;
        }
        h1 { border-bottom: 1px solid #444; padding-bottom: 10px; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th, td { border: 1px solid #444; padding: 10px 12px; text-align: left; }
        thead { background-color: #2a2a2a; }
        tbody tr:nth-child(odd) { background-color: #252525; }
        a { color: #4e94ce; text-decoration: none; margin-right: 15px; }
        a:hover { text-decoration: underline; }
        .session-id { font-family: monospace; font-size: 0.9em; max-width: 200px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .no-sessions td { text-align: center; padding: 30px; color: #888; }
    </style>
</head>
<body>

<h1>Активные сессии</h1>
<table>
    <thead>
    <tr>
        <th>ID Сессии</th>
        <th>Клиенты (Всего / RW / RO)</th>
        <th>Создана</th>
        <th>Ссылки для подключения</th>
    </tr>
    </thead>
    <tbody id="sessions-table-body">
    <!-- Сюда будут добавляться сессии -->
    </tbody>
</table>
<p><a href="/">Перейти к терминалу</a></p>

<script>
    const termContainer = document.getElementById('terminal');
    const rwLinkEl = document.getElementById('rw-link');
    const roLinkEl = document.getElementById('ro-link');

    const params = new URLSearchParams(window.location.search);
    const roSessionId = params.get('ro');

    let sessionId;
    let isReadOnly = false;
    let wsPath = '/ws/';

    if (roSessionId) {
        sessionId = roSessionId;
        isReadOnly = true;
        wsPath = '/ws-ro/';
    } else if (window.location.hash) {
        sessionId = window.location.hash.substring(1);
    } else {
        sessionId = Date.now().toString(36) + Math.random().toString(36).substring(2);
        window.location.hash = sessionId;
    }

    const baseUrl = window.location.origin + window.location.pathname;
    rwLinkEl.textContent = `${baseUrl}#${sessionId}`;
    roLinkEl.textContent = `${baseUrl}?ro=${sessionId}`;

    const term = new Terminal({
        cursorBlink: true,
        fontSize: 14,
        fontFamily: 'monospace',
        theme: { background: '#1e1e1e', foreground: '#d4d4d4' },
        disableStdin: isReadOnly
    });

    const fitAddon = new FitAddon.FitAddon();
    term.loadAddon(fitAddon);
    term.open(termContainer);

    // --- НАЧАЛО ИЗМЕНЕНИЙ ---

    const protocol = (location.protocol === 'https-:') ? 'wss://' : 'ws://';
    const wsUrl = protocol + location.host + wsPath + sessionId;
    const ws = new WebSocket(wsUrl); // 1. Сначала объявляем и инициализируем ws

    function fitTerminal() {
        fitAddon.fit();
        const dims = { type: 'resize', cols: term.cols, rows: term.rows };
        // Проверка на 'ws' здесь по-прежнему полезна, так как соединение может быть не открыто
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify(dims));
        }
    }

    window.onresize = fitTerminal; // 2. Теперь безопасно назначать обработчик

    // --- КОНЕЦ ИЗМЕНЕНИЙ ---

    ws.onopen = function() {
        fitTerminal(); // Вызываем, чтобы подогнать размер при открытии
        term.focus();
    };

    ws.onmessage = function(event) {
        // Код обработки сообщений остается без изменений
        if (event.data instanceof Blob) {
            const reader = new FileReader();
            reader.onload = function() {
                // В вашем коде было new Uint8Array(reader.result), но для xterm.js лучше просто reader.result, если данные текстовые
                // Если данные бинарные, то Uint8Array корректен.
                term.write(new Uint8Array(reader.result));
            };
            reader.readAsArrayBuffer(event.data);
        } else {
            term.write(event.data);
        }
    };

    ws.onclose = function() {
        term.write('\r\n\r\n[CONNECTION CLOSED]\r\n');
    };

    term.onData(function(data) {
        if (!isReadOnly && ws.readyState === WebSocket.OPEN) { // Добавлена проверка состояния
            ws.send(data);
        }
    });
</script>

</body>
</html>